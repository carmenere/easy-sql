# Functional dependency
The **functional dependency** is a **relationship** that exists between **two** sets of attributes under some relation `R`.<br>
The **functional dependency** is denoted as `X → Y`, where
- the **attribute set** on the **left** side (`X`) is called **determinant**;
- the **attribute set** on the **right** side (`Y`) is called the **dependent**.

<br>

Functional dependencies are **directional**: `A → B` does not mean than `B → A`.

<br>

Variants to read notation `X → Y`:
- `X` functionally determines `Y`;
- `Y` is functionally dependent on `X`;

<br>

# Validating a FD
If the **same** value of `X` gives the **different** values of `Y`, then it is **not** FD, for instance:
|`X`|`Y`|
|:--|:--|
|`{1, 2}`|`{33}`|
|`{1, 2}`|`{55}`|

<br>

But **different** values of `X` can give the **same** values of `Y` and it is valid **FD**:
|`X`|`Y`|
|:--|:--|
|`{1, 2}`|`{33}`|
|`{3, 4}`|`{33}`|


<br>

# Regular vs. irregular
- a functional dependency `X → Y` is **regular** if `Y` contains only a **single** attribute.
- a functional dependency `X → Y` is **irregular** if `Y` contains more than one attributes.

<br>

For example, `AB → C` is **regular**, but `AB → CD` is **irregular**, where `A`, `B`, `C`, and `D` are attributes.<br>

Strictly speaking, there is always **only one** attribute on the **right** side, but we can **combine** several functional dependencies **into one**:
- `{A, B} → {Q}`;
- `{A, B} → {W}`;
- `{A, B} → {Q, W}`;

> **Note**:<br>
> Remember, that `{A, B} → {Q, W}` is really shorthand for **two** functional dependencies.<br>

<br>

# Types of FD
Types of FD:
- **trivial** FD;
- **non-trivial** FD;
- **partial** FD;
- **multivalued** FD;
- **transitive** FD;

<br>

## Trivial FD
In **trivial** FD, a *dependent* (`Y`) is always a **subset** of the *determinant* (`X`), i.e. if `X → Y` is FD and `Y ⊆ X`, then it is called a **trivial** FD.<br>
Every set of attributes `X` is **trivially** dependent on itself: `X → X`.<br>

<br>

### Examples
- `{A} → {A}`
- `{A,B} → {A}`
- `{A,B,C} → {A,C}`


<br>

## Non-trivial FD
In **non-trivial** FD, the *dependent* (`Y`) is **not** a **subset** of the *determinant* (`X`), i.e. if `X → Y` is FD and `Y ⊈ X`, then it is called a **non-trivial** FD.<br>

<br>

### Example
- `{A} → {B}`

<br>

# Partial Dependency
**Partial dependency** – FD where an attribute in a relation depends on only a **part** of the **primary key** and **not** on the **whole key**.

<br>

## Multivalued FD
In **multivalued** FD, attributes of the *dependent* (`Y`) set are **not** dependent on **each other**, i.e. if `a → {b, c}` and there is **no** FD between `b` and `c`, then it is called a **multivalued** FD.<br>

<br>

## Transitive FD
FD is said to be **transitive** if it is **indirectly** formed by **two** FD, i.e. if there are exist 3 FDs: `a → b`, `b → c` and `a → c`, then `a → c` is called a **transitive** FD.<br>

<br>

### Example
Consider table `T`: 
|A|B|C|
|:-|:-|:-|

<br>

In this table following FD exist:
- `A → B`;
- `B → C`;

<br>

So, this table introduces **transitive dependency** `A → C`.

<br>

# Keys
**Superkey** is a **set of attributes** that **uniquely** identifies **each tuple** of a relation.<br>
The set of **all** attributes is always a superkey (aka **trivial superkey**).<br>

A **candidate key** (or **minimal superkey**) is a **superkey** that **can't** be reduced to a simpler superkey by removing an attribute.<br>
There can be more than 1 **candidate key** in relation.<br>

**Primary key** is the **candidate key** chosen to be **primary**. Usually it is **minimal** *candidate key*. Any other *candidate key* is an **alternate key**.<br>

A *primary key* may consist of values from **real** domains and is called a **natural key**.

**Surrogate key** (**synthetic key**, **entity identifier** in a database is a unique identifier for either an entity in the modeled world or an object in the database.<br>

The **surrogate key** can be the **primary key**, generated by the db automatically.<br>

**Prime attribute** is an attribute of a relation that is a member of **any** *candidate key*.<br>

**Non-prime Attribute** is an attribute of a relation that **isn't** a **prime attribute**.<br>

<br>

# Set of functional dependencies
**Set of FDs** `F` of a relation is the **set** of **all** FDs presented in this relation.<br>
For instance, there is given relation `R(A, B, C, D, E, F)` and its **FD set** `F = {AB->C, BC->AD, D->E, CF->B}`. 

<br>

# Closure of an attribute set
The **closure** `X+` **of an attribute set** `X` with respect to **FD set** `F` is a set of **all** attributes which can be functionally determined from attribute set `X`.<br>

Assume that there are some relation `R`, some `F` and the **set of attributes** `X = {A}`.<br>
The general algorithm to find **closure** `X+` of`X`:
1. Add `A` and `B` to the result set `X+` (every set of attributes `X` is **trivially** dependent on itself).
2. Add the attributes to the result set `X+` which can be functionally determined from the attributes already contained in the result set `X+`.
3. Repeat step **2** until no more attributes can be added to the result set `X+`.

<br>

### Example 1
Assume that there is the relation `R(A, B, C, D, E)` and `F = {AB -> CD, D -> E, A -> C, B -> D}`.<br>

We can determine `A+` as:    
1. Add `A` to the result set `A+ = {A}`.
2. Get all the attribute which are derived from `A` and add them to the result set `A+`:
   - `A -> C` (from given **set of FDs**);
   - add `C` to the `A+`;
   - now `A+` contains `{A,C}`;
3. No other attribute can be derived from `A` and `C` hence.

**Result**: `A+ = {A,C}`.

<br>

### Example 2
Assume that there is the relation `R(A, B, C, D, E)` and `F = {AB -> CD, D -> E, A -> C, B -> D}`.<br>

We can determine `B+` as:    
1. Add `B` to the result set `B+ = {B}`.
2. Get all the attribute which are derived from `B`:
   - `B -> D` (from given **set of FDs**);
   - add `D` to the `B+`;
   - now `B+` contains `{B,D}`;
3. Get all the attribute which are either derived by `D` or any combination of `BD` (all subsets of `B+` excluding `{B} and {}`)
   - `D -> E`
   - add `E` to the `B+`;
   - now `B+` contains `{B,D,E}`;
4. No other attribute can be derived from `B`, `D`, `E` or from any combination of `B`, `D`, `E` hence.

**Result**: `B+ = {B,D,E}`.

<br>

# Closure of set of FDs
The **closure** of **set of FDs** `F`, denoted as `F+`, is the **set** of **all regular FDs** that can be derived from `F`.<br>
There are **inference rules** (aka **Armstrong's inference rules**) to infer **all regular FDs** from `F`.<br>
**Armstrong's inference rules** are **sufficient** to infer `F+` from given `F`.<br>
Some inferred FDs are trivial: the **dependent** is a **subset** of the **determinant**, e.g., `AB → A`, `AB → B`.

<br>

### Example
Assume that there is relation `R(A, B, C , D)` and `F = {A → B, B → C }`.<br>
Then, `F+` is **set** of following FDs (some inferred FDs are trivial):
- `A → A`
- `A → B`
- `A → C`
- `B → B`
- `B → C`
- `C → C`
- `D → D`
- `AB → A`
- `AB → B`
- `AB → C`
- `AC → A`
- `AC → B`
- `AC → C`
- `AD → A`
- `AD → B`
- `AD → C`
- `AD → D`
- `BC → B`
- `BC → C`
- `BD → B`
- `BD → C`
- `BD → D`
- `CD → C`
- `CD → D`
- `ABC → A`
- `ABC → B`
- `ABC → C`
- `ABD → A`
- `ABD → B`
- `ABD → C`
- `ABD → D`
- `BCD → B`
- `BCD → C`
- `BCD → D`
- `ABCD → A`
- `ABCD → B`
- `ABCD → C`
- `ABCD → D`

<br>

# Find candidate key by clojure
Let `F` is a set of FDs, and `R` a relation.<br>

A **candidate key** is a set `C` of attributes in `R` such that
- `C+` includes all the attributes in `R`;
- there is no **proper subset** `S` of `C` such that `S+` includes **all** the attributes in `R`.

<br>

A **proper subset** `S` is a **subset** of `C` such that `S != C`.

<br>

### Example
Assume that there is relation `R(A, B, C , D)` and `F = {A → B, B → C }`:
- `A` is **not** a candidate key `C`, because `A+ = {A, B, C }` which does **not** include `D`.
- `ABD+ = {A, B, C , D}`, but `ABD` is **not** a candidate key `C` because there is a **proper subset** `AD` of `ABD` such that `AD+` includes all the attributes: `AD+ = {A, B, C , D}`.
- `AD` is a **candidate key** `C`.
